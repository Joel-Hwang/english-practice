<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Practice</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Bootstrap 5 CDN -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
  </head>
  <body class="bg-light" style="margin: 10px">
    <div class="mb-4">
      <h5>Question</h5>
      <p class="mb-0">{{ reply.question }}</p>
    </div>

    <div class="mb-4">
      <h5>Your Answer</h5>
      <p class="mb-0">{{ reply.answer }}</p>
    </div>
    <div class="mb-4">
      <h5>
        Corrected Answer
        <span
          id="uploadVoice"
          onclick="uploadVoice('{{ reply._id }}')"
          style="display: none"
          >🔊</span
        >
      </h5>
      <audio id="correctedAudio" controls style="display: none">
        <source src="" type="audio/mpeg" />
        이 브라우저는 오디오 태그를 지원하지 않습니다.
      </audio>
      <p class="mb-0" id="corrected">{{ reply.corrected }}</p>
    </div>

    <div class="mb-4">
      <h5 id="h5corrections" onclick="toggleExplanations()">Corrections 🔽</h5>
      <ul
        class="list-group list-group-flush"
        id="explanations"
        style="display: none"
      >
        {% for explanation in reply.explanations %}
        <li class="list-group-item">{{ explanation }}</li>
        {% endfor %}
      </ul>
    </div>

    <div>
      <button class="btn" id="btnStart">🔴 Record</button>
    </div>
    <div
      class="d-flex align-items-start"
      id="recordArea"
      style="justify-content: center; flex-wrap: wrap"
    ></div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      const spanResult = document.getElementById("spanResult");
      const btnStart = document.getElementById("btnStart");
      let isManuallyStopped = true;
      window.onload = () => {
        recorder.init();
        displayAudio("{{ reply.audioUrl }}");
      };
      function displayAudio(audioUrl) {
        const correctedAudio = document.getElementById("correctedAudio");
        const uploadVoice = document.getElementById("uploadVoice");
        if (audioUrl) {
          correctedAudio.src = audioUrl;
          uploadVoice.style.display = "none";
          correctedAudio.style.display = "block";
        } else {
          correctedAudio.style.display = "none";
          uploadVoice.style.display = "inline";
          uploadVoice.style.cursor = "pointer";
        }
      }

      let recorder = {
        mediaRecorder: {},
        chunks: [],
        init: () => {
          const audioCtx = new (window.AudioContext ||
            window.webkitAudioContext)(); // 오디오 컨텍스트 정의
          const analyser = audioCtx.createAnalyser();
          navigator.mediaDevices
            .getUserMedia({ audio: true })
            .then((stream) => {
              recorder.mediaRecorder = new MediaRecorder(stream);
              recorder.mediaRecorder.onstop = recorder.addPlayer;

              recorder.mediaRecorder.ondataavailable = (e) => {
                recorder.chunks.push(e.data);
              };
            });
        },
        start: () => {
          recorder.mediaRecorder.start();
        },
        stop: () => {
          recorder.mediaRecorder.stop();
        },
        addPlayer: async (e) => {
          const clipContainer = document.createElement("article");
          const clipLabel = document.createElement("p");
          const audio = document.createElement("audio");
          clipContainer.classList.add("clip");
          audio.setAttribute("controls", "");
          audio.style.width = "250px";
          clipContainer.appendChild(audio);
          audio.controls = true;
          const blob = new Blob(recorder.chunks, {
            type: "audio/ogg codecs=opus",
          });
          recorder.chunks = [];
          const audioURL = URL.createObjectURL(blob);
          audio.src = audioURL;
          console.log("recorder stopped");

          let html = `
                    <div class="card" style="width: 18rem; margin: 10px;">
                        <div class="card-body">
                        </div>
                    </div>`;
          const template = document.createElement("template");
          template.innerHTML = html;
          template.content
            .querySelector(".card-body")
            .appendChild(clipContainer);
          document.querySelector("#recordArea").prepend(template.content);

          await transcribe(blob);
        },
      };

      btnStart.onclick = () => {
        if (isManuallyStopped) record();
        else cancelRecord();
      };

      function record() {
        isManuallyStopped = false;
        btnStart.innerText = "🚫 Stop";
        recorder.start();
      }

      function cancelRecord() {
        btnStart.innerText = "🔴 Record";
        isManuallyStopped = true;
        recorder.stop();
      }

      async function uploadVoice(historyId) {
        const uploadVoice = document.getElementById("uploadVoice");
        uploadVoice.innerText = "🫦";
        uploadVoice.style.disabled = true;
        const corrected = document.getElementById("corrected").innerText;
        try {
          const response = await fetch("/upload-voice", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            credentials: "include", // 세션 쿠키 포함
            body: JSON.stringify({
              historyId: historyId,
              corrected: corrected,
            }),
          });

          const resJson = await response.json();
          if (response.ok) {
            displayAudio(resJson.audioUrl);
          } else {
            alert(`업로드 실패: ${resJson.error}\n상세: ${resJson.detail}`);
          }
        } catch (error) {
          console.error("에러 발생:", error);
        } finally {
          uploadVoice.innerText = "🔊";
          uploadVoice.style.disabled = false;
        }
      }

      function toggleExplanations() {
        const explanations = document.getElementById("explanations");
        const h5corrections = document.getElementById("h5corrections");
        if (explanations.style.display === "none") {
          explanations.style.display = "block";
          h5corrections.innerText = "Corrections 🔼";
        } else {
          explanations.style.display = "none";
          h5corrections.innerText = "Corrections 🔽";
        }
      }

      async function transcribe(blob) {
        const formData = new FormData();
        formData.append("file", blob, "audio.ogg");
        try {
          const response = await fetch("/transcribe", {
            method: "POST",
            body: formData,
          });
          const result = await response.json();
          alert(
            result.text +
              "\n" +
              getLevenshteinSimilarity(result.text, "{{ reply.corrected }}")
          );
        } catch (err) {
          alert("⚠️ 오류 발생: " + err.message);
        }
      }

      function getLevenshteinSimilarity(a, b) {
        a = a.toLowerCase().replace(/[^a-zA-Z0-9]/g, "");
        b = b.toLowerCase().replace(/[^a-zA-Z0-9]/g, "");

        const m = a.length;
        const n = b.length;
        const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;

        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            const cost =
              a[i - 1].toLowerCase() === b[j - 1].toLowerCase() ? 0 : 1;
            dp[i][j] = Math.min(
              dp[i - 1][j] + 1, // deletion
              dp[i][j - 1] + 1, // insertion
              dp[i - 1][j - 1] + cost // substitution
            );
          }
        }
        const distance = dp[m][n];
        const similarity = 1 - distance / Math.max(m, n);
        return similarity;
      }
    </script>
  </body>
</html>
